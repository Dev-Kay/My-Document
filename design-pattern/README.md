# Design Pattern (디자인 패턴)

### :book: Contents

1. [객체 지향 프로그래밍](#객체지향-프로그래밍object-oriented-programming)
2. [객체지향 5대 설계 원칙 (SOLID)](#객체지향-5대-설계-원칙-SOLID)


### 객체지향 프로그래밍(Object-Oriented Programming)

- 정의
  - 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법
  - 그냥 데이터의 흐름의 관점에서 하나하나의 객체(Object)들이 유기적으로 지지고 볶고 각자의 역할을 수행하며 원활하게 이뤄지게 프로그래밍 하는거?
  - 객체가 뭔데?
    - 구현화 된 클래스? 사람, 과일, 자동차 이런것을 추상적인 개념이라고 한다면 실체가 있는 철수,영희, 바나나, 사과, X5, 까레라 뭐 이런 것들을 객체라고 한다.
    - 자 그럼 Object-Oriented 번역하면 객체지향, 객체에 맞춰주다, 객체 위주의등등 즉, 객체 철수 
    
- 장점
  - 프로그램을 이해하고 파악하기 쉽다.
  - 강한 응집력(Strong Cohesion)과 약한 결합력(Weak Coupling)을 가진다.
  - 재사용, 확장성이 좋아 유지보수가 용이 하다.
  
- 단점
  - 느리다. 여러 객체 사이 정보의 교환으로 데이터를 처리 하다보니 절차지향보다상대적으로 느림
  - 설계에 아무래도 신경을 오래쓰다보니 많은 시간과 노력이 필요.
  - 규모가 커질 수록 객체가 많이 생성되니 사이즈와 갯수가 커지겠지.
  
- 특징
  - 추상화   
    불필요한 정보는 숨기고 중요한 정보만을 표현함으로써 `공통의 속성이나 기능을 묶어 이름을 붙여 추출해둔것.` 주요 관심사에만 집중함으로써, 프로그램의 복잡도를 관리할 수 있다.   
    Ex) 사람, 탈것, 과일   
  - 캡슐화   
    `관심있는 데이터와 기능을 모아놓고 패킹한 것.` 내부의 데이터나 함수를 외부에서 참조하지 못하도록 차단하는 개념을 정보 은닉화(Information Hiding)라고 하며 이것이 바로 캡슐화라는 개념이다.   
    Ex) getter, setter?
  - 상속
    `부모클래스의 속성과 기능을 그대로 이어받아 사용할 수 있게하고` 기능의 일부분을 변경해야 할 경우 상속받은 자식클래스에서 해당 메서드를 수정하여 사용할 수 있게 하는 것   
    단, 다중상속은 불가능
  - 다형성   
    `같은 메서드에 상황에 따라 다른 방식으로 동작하는 성질.`
      - Overriding   
        class or interface를 상속 받아 부모에 정의 되어있는 메서드를 재정의 하여 사용 하는것
        class는 뭐.. 재정의 안하면 부모 메서드가 실행 되지만 interface는 무조건 overriding 해야 한다.
      - Overloading   
        메소드에 주어진 매게변수의 타입, 갯수에 따라 동작을 다르게 구현 할 수 있다. 코드의 중복이 줄어들고, 가독성이 늘어난다.
  - 클래스(class), 인스턴스(instance)   
      - 클래스 : 문제 해결을 위한 객체를 만들기 위해 상태(field)와 행위(method)를 정의한 틀.
      - 인스턴스(객체) : 클래스에서 정의한 것을 토대로 실제 메모리상에 할당된 것으로 실제 프로그램에서 사용되는 데이터
  - 메시지   
    객체지향적으로 구현된 프로그램은 객체들끼리의 메시지를 주고받고 상호작용하며 동작한다. 코드적으로는 임의의 객체에게 인자(parameter)를 전달하여 메소드를 호출하며 반환값(return value)을 받아 처리를 한다.
    
:memo:[자세히 보기](./contents/object-oriented-programming.md)

### 객체지향 5대 설계 원칙 (SOLID)

- SRP(Single Responsibility Principle)단일 책임 원칙   
  클래스는 단 하나의 책임을 가져야 하며 클래스를 변경하는 이유는 단 하나의 이유이어야 한다.
- OCP(Open-Closed Principle) : 개방-폐쇄 원칙     
  `기존의 코드를 변경하지 않고(Closed) 기능을 수정하거나 추가할 수 있도록(Open) 설계해야 한다.`   
  추상 클래스나 인터페이스는 변하지 않고(CLOSE) 상속을 받은 구현체의 경우 얼마든지 추가 확장이 가능하다.   
  Ex) 동전투입기(CLOSE) - 제조사A 달러투입, 제조사B 원화투입기 ..... (확장 및 변경 가능 = OPEN)
- LSP(Liskov Substitution Principle) : 리스코프 치환 원칙   
  `상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야 한다.`   
  Ex) List l = ArrayList(); l.add(d); ==> List l = LinkedArrayList(); l.add(d) // 정상적으로 구동됨   
- ISP(Interface Segregation Principle) : 인터페이스 분리 원칙   
  `하나의 인터페이스에서 모든것을 처리 하기 보다, 사용하는 클라이언트를 기준으로 분리해야 한다.`   
  Ex) 자판기는 동전투입, 상품선택, 거스름돈 반환의 동작이 있지만 모든 작업을 한번에 수행 하지 않는다. 하여 클라이언트 즉 사용자의 행위를 기준으로 동전 투입▪상품 선택▪거스름돈 반환 interface  를 각각 상속받아 구현하고 클라이언트는 분리된 interface를 호출 하도록 한다.
- DIP(Dependency Inversion Principle) : 의존 역전 원칙   
  `의존 관계를 맺을 때, 변화하기 쉬운것 보단 변화하기 어려운 것에 의존해야 한다`   
  뭐... OCP 원칙을 만족하려면... 당연히 이 원칙을 만족해야 하지 않나 싶은데;;   
  Ex) 동전투입기 - A사, B사,C사...... ==> 동전투입기 제조사가 아무리 바껴도 동전이 투입되고 일어나는 행위는 변하지 않음

:memo:[자세히 보기](./contents/object-oriented-solid.md)
